# 双端Diff算法
## 双端比较原理
简单Diff算法对DOM的移动不是最优的
双端Diff算法：同时对新旧两组子节点的两个端点进行比较：
1. 第一个新子节点比较第一个旧子节点
2. 最后一个新子节点比较最后一个旧子节点
3. 最后一个新子节点比较第一个旧子节点
4. 第一个新子节点比较最后一个旧子节点
我们需要给出上面几种情况的不同处理方式：
1. 新一旧一是同一个节点，不需要移动，只更新索引
2. 新末和旧末是同一个节点，不需要移动，只更新索引
3. 新末和旧一是同一个节点，需要将旧一移动到旧末的后面
4. 新一节点和旧末子节点是同一个节点，则需要先更新旧末的内容，再把旧末移动到旧一的前面

## 双端比较的优势
假设一个长度为4的子节点，将最后一个子节点移动到了第一个，简单Diff算法需要移动3次，而双端Diff算法只需要移动一次DOM。

## 非理想状况的处理方式
两个头部和两个尾部节点都没有可复用的节点，则用新一组子节点中的头部节点去和旧一组子节点比较
拿到新一在旧组中的索引，该索引对应的旧子节点就是新一，更新该子节点，然后把该子节点放到旧一的前面，将该索引对应的引用清空
如果后续遇到为undefined的旧头尾子节点，直接更新索引并跳过，因为他们已经被处理过了

## 添加新元素
当我们用新一去旧组找相同子节点却没找到时，说明新一是个新子节点
当循环完成时，新一组子节点还有未处理的元素，证明该元素是新增的，将未处理的元素放在当前指向的旧一前面

## 移除不存在的元素
当循环完成时，旧一组节点还有未处理的元素，证明该元素需要被卸载
