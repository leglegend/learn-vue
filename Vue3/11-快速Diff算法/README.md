# 快速Diff算法
快速Diff算法比Vue2所采用双端Diff算法更快，所以Vue3中使用的也是快速Diff算法。
## 相同前置元素和后置元素
先对两组子节点进行预处理，找出相同前置元素并更新，将前置元素索引设置为最后一个相同的前置元素的下一个。
找出相同后置元素，后置元素的索引是从末尾开始的，新旧两组子节点长度不一定相同，所以有两个后置元素索引。
从后向前找出相同的后置元素并更新，后置索引停留在最后一个相同的后置元素的下一个。
预处理完成后，我们得到三个索引，一个前置索引和两个后置索引(新子节点索引和旧直接点索引)。
当新子节点的索引值大于等于前置索引值，并且旧子节点索引小于前置索引时，证明有新增元素，对前置索引和新子节点索引之间的元素进行挂载操作，将新子节点索引的后一个元素作为锚点。
反过来，如果前置索引大于新后索引，证明新一组子节点遍历完了，这时前置索引小于等于旧后索引，则旧一组子节点还有未处理的元素，这时需要卸载多出来的元素，即前置索引到旧后索引之间的元素。
## 判断是否需要DOM操作
上面是理想状况下的操作方式，还需要考虑非理想情况：
如果预处理完成时，前置索引仍小于两个后置索引，则需要特殊处理。
我们可以排除预处理处理完的数据，只考虑剩余的子节点：
新一组剩余子节点：前置所有->新后置索引
旧一组剩余子节点：前置索引->旧后置索引
先生成一个source数组，该数组长度为剩余新一组节点的数量，数组元素默认值为-1，保存新子节点对应的旧子节点的位置。
从两个数组中找到新子节点对应旧子节点的索引值，找不到则说明需要卸载该节点。
可以初始化一个patched，保存已处理新子节点数，当处理数等于总数时，之后的节点都卸载掉就可以了。
子节点是否需要移动是按照简单Diff算法来的，保存一个最大索引值pos，如果当前节点索引值大于等于最大索引，就不需要移动，并把当前索引赋值给最大索引。
## 如何移动元素
上面判断出是否需要移动元素
如果需要移动，则先通过source生成一个新子节点的最大增长子序列，返回该子序列元素在source的索引值
然后从新一组子节点从后向前遍历
首先判断当前子节点对应的source值是否为-1，-1代表新增，挂载到新一组子节点的后面，相同后置元素的前面。
再判断当前节点在source中的索引值是否包含在最大子序列中，包含则不需要移动，不包含则需要移动到其后一个子节点的前面。
这里之所以能放到后一子节点的前面，是因为我们从后往前遍历，后面的子节点已经处理并移动完成了，可以当作锚点。