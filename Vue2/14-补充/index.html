<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script name="state">
      function initState(vm) {
        vm._watchers = []
        const opts = vm.$options
        if (opts.props) initProps(vm, opts.props)
        if (opts.methods) initMethods(vm, opts.methods)
        if (opts.data) {
          initData(vm)
        } else {
          observe((vm._data = {}), true /* asRootData */)
        }
        if (opts.computed) initComputed(vm, opts.computed)
        if (opts.watch && opts.watch !== nativeWatch) {
          initWatch(vm, opts.watch)
        }
      }
    </script>
    <script name="props">
      // 格式化props
      function nomalizeProps(options, vm) {
        const props = options.props
        if (!props) return
        const res = {}
        let i, val, name
        if (Array.isArray(props)) {
          i = props.length
          while (i--) {
            val = props[i]
            if (typeof val === 'string') {
              name = camelize(val) // 将 user-name 转换为 userName
              res[name] = { type: null }
            }
          }
        } else if (isPlainObject(props)) {
          for (const key in props) {
            val = props[key]
            name = camelize(key)
            res[name] = isPlainObject(val) ? val : { type: val } // propA:Number -> type:Number
          }
        }
        options.props = res
      }
      // 初始化props
      function initProps(vm, propsOptions) {
        const propsData = vm.$options.propsData || {}
        const props = (vm._props = {})
        // 缓存props的key
        const keys = (vm.$options._propKeys = [])
        const isRoot = !vm.$parent
        // root实例的props属性应该转换成响应式
        if (!isRoot) {
          toggleObserving(false)
        }
        for (const key in propsOptions) {
          keys.push(key)
          const value = validateProp(key, propsOptions, propsData, vm)
          defineReactive(props, key, value)
          if (!(key in vm)) {
            proxy(vm, '_props', key)
          }
        }
        toggleObserving(true)
      }

      function validateProp(key, propOptions, propsData, vm) {
        const prop = propOptions[key]
        const absent = !hasOwn(propsData, key)
        let value = propsData[key]
        // 处理布尔类型的props
        if (isType(Boolean, prop.type)) {
          if (absent && !hasOwn(prop, 'default')) {
            value = false
          } else if (
            !isType(String, prop.type) &&
            (value === '' || value === hyphenate(key))
          ) {
            value = true
          }
        }
        // 检查默认值
        if (value === undefined) {
          value = getPropDefaultValue(vm, prop, key)
          // 因为默认值是新的数据，所以需要将它转换成响应式的
          const prevShouldConvert = observerState.shouldConvert
          observerState.shouldConvert = true
          observe(value)
          observerState.shouldConvert = prevShouldConvert
        }
        return value
      }
    </script>
    <script name="methods">
      function initMethods(vm, methods) {
        const props = vm.$options.props
        for (const key in methods) {
          vm[key] = methods[key] == null ? noop : bind(methods[key], vw)
        }
      }
      function noop() {}
    </script>
    <script name="data">
      function initData(vm) {
        let data = vm.$options.data
        data = vm._data =
          typeof data === 'function' ? getData(data, vm) : data || {}
        if (!isPlainObject(data)) {
          data = {}
        }
        // 将data代理到Vue实例上
        const keys = Object.keys(data)
        const props = vm.$options.props
        const methods = vm.$options.methods
        let i = keys.length
        while (i--) {
          const key = keys[i]
          if (props && hasOwn(props, key)) {
          } else if (!isReserved(key)) {
            proxy(vm, '_data', key)
          }
        }
        // 观察数据
        observe(data, true /* asRootData */)
      }

      const sharedProertyDefinition = {
        enmuerable: true,
        configurable: true,
        get: noop,
        set: noop
      }
      function proxy(target, sourceKey, key) {
        sharedProertyDefinition.get = function proxyGetter() {
          return this[sourceKey][key]
        }
        sharedProertyDefinition.set = function proxySetter(val) {
          this[sourceKey][key] = val
        }
        Object.defineProperty(target, key, sharedProertyDefinition)
      }
    </script>
    <script name="computed"></script>
  </body>
</html>
