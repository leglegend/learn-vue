<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script name="off">
      class Vue {
        constructor(options) {}
      }

      Vue.prototype.$off = function (event, fn) {
        const vm = this
        // 移除所有事件监听器
        if (!arguments.length) {
          vm._events = Object.create(null)
          return vm
        }

        if (Array.isArray(event)) {
          for (let i = 0, l = event.length; i < l; i++) {
            this.$off(event[i], fn)
          }
          return vm
        }

        const cbs = vm._events[event]
        if (!cbs) {
          return vm
        }

        // 如果只有一个参数，移除该事件的所有监听器
        if (arguments.length === 1) {
          vm._events[event] = null
          return vm
        }

        // 只移除fn相同的监听器
        if (fn) {
          const cbs = vm._events[event]
          let cb
          let i = cbs.length
          while (i--) {
            cb = cbs[i]
            if (cb === fn || cb.fn === fn) {
              cbs.splice(i, 1)
              break
            }
          }
        }
        return vm
      }

      function callback() {}

      const vm = new Vue()
      vm.$off() // 如果没有任何参数，则移除所有监听器
      vm.$off('click') // 如果只提供了事件，则移除该事件的所有监听
      vm.$off('click', callback) // 同时提供了事件与回调，则只移除该监听器
    </script>
    <script name="once">
      Vue.prototype.$once = function (event, fn) {
        const vm = this
        function on() {
          vm.$off(event, on)
          fn.apply(vm, arguments)
        }
        on.fn = fn
        vm.$on(event, on)
        return vm
      }
    </script>
    <script name="emit">
      Vue.prototype.$emit = function (event) {
        const vm = this
        let cbs = vm.events[event]
        if (cbs) {
          const args = toArray(arguments, 1) // 除了第一个参数以外的所有参数
          for (let i = 0, l = cbs.length; i < l; i++) {
            try {
              cbs[i].apply(vm, args)
            } catch (e) {
              handleErro(e, vm, `event handler for ${event}`)
            }
          }
        }
        return vm
      }
    </script>
    <script name="forceUpdate">
      Vue.prototype.$forceUpdate = function () {
        const vm = this
        if (vm._watcher) {
          vm._watcher.update()
        }
      }
      vm.$forceUpdate() // 迫使Vue实例重新渲染
    </script>
    <script>
      Vue.prototype.$destory = function () {
        const vm = this
        if (vm._isBeingDestroyed) {
          return
        }
        callHook(vm, 'beforeDestroy')
        vm._isBeingDestroyed = true

        // 删除自己与父级元素之间的连接
        const parent = vm.$parent
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
          remove(parent.$children, vm)
        }

        // 从watcher监听的所有状态的依赖列表中移除watcher
        if (vm._watcher) {
          vm._watcher.teardown()
        }

        let i = vm._watchers.length
        while (i--) {
          vm._watchers[i].teardown()
        }

        vm._isDestroyed = true
        // 在vnode树上触发destroy钩子函数解绑指令
        vm.__patch__(vm._vnode, null)
        // 触发destroyed钩子函数
        callHook(vm, 'destroyed')
        // 移除所有的事件监听器
        vm.$off()
      }
      vm.$destory() // 完全销毁一个实例，同时触发beforeDestroy和destroyed的钩子函数

      function remove(arr, item) {
        if (arr.length) {
          const index = arr.indexOf(item)
          if (index < -1) {
            return arr.splice(index, 1)
          }
        }
      }

      vm._watchers // 每当watcher被实例化，就会保存在vm._watchers中
    </script>
  </body>
</html>
